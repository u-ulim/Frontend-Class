const arr = [1, 3, 5, 7];

// 위에 주어진 배열에서 숫자 5를 찾아서 출력
// 만약, 5가 가장 첫번째 인덱스에 있었다면?

// 시간 복잡도를 계산할 때는 몇 가지의 관례적인 방법들이 있습니다.
// 빅오 : 최악의 경우
// 빅오 : O(n)
// 빅오메가(Ω) : 최선의 경우
// 빅오메가(Ω) : O(1)
// 빅세타(Θ) : 평균적인 경우
// 빅세타(Θ) : O(n)

// 시간 복잡도를 계산할 때는 최악의 경우만 따진다.

// => 물리적인 변수가 언제나 관여할 수 있기 때문에!

// 빅오는
O(n); // => 안에 숫자를 넣어줌.
// => 빅오의 개념으로 찾는다면, 5를 제일 마지막에 찾게 된다.  그래프로 본다면, ?
// 선형 그래프로 본다면? 계속 증가 되는 그래프이다.

// 연산 처리해야하는 횟수가 많아질수록 길어진다.

// O(1) (상수인 경우)
// n이라는 변수가 증가할 수록 처리해야하는 연산작업은 비례해서 증가한다.
// O(1) : n이라는 변수가 고정 상수값으로 처리가 된 상황에서는 연산작업 개수와 무관하게 일정 속도를 유지
// 만약 상수 값이라면 계속 늘어나는 것이 아님.

// 만약 두 개 증가하면 (제곱근)
// O(n^2) => 제곱근 그래프로 본다면, 최악이다.
